# 6. 프로세스 동기화

## 데이터의 접근

<img title="" src="./img/014.png" alt="" width="368" data-align="center">

## Race Condition

<img title="" src="./img/015.png" alt="" width="454" data-align="center">

(한 데이터를 동시에 두 군데에서 접근하면 synchronization의 문제가 생길 수 있음)

## OS에서 race condition은 언제 발생하는가?

1. kernel 수행 중 인터럽트 발생 시

2. Process가 system call을 하여 kernel mode로 수행 중인데 context switch가 일어나는 경우

3. Multiprocessor에서 shared memory 내의 kernel data 

<img title="" src="./img/016.png" alt="" width="404" data-align="center">

(작업이 끝날 때까지는 인터럽트 처리를 하지 않음으로 해결)

<img title="" src="./img/017.png" alt="" width="328" data-align="center">

<img title="" src="./img/018.png" alt="" width="370" data-align="center">

(커널 모드 수행 중일 때는 CPU를 선점당하지 않는 것으로 해결)

<img title="" src="./img/019.png" alt="" width="368" data-align="center">

(한 번에 한 CPU만 허용하게 하거나, 데이터를 lock하는 방법으로 해결)

## Process Synchronization 문제

- 공유 데이터(shared data)의 동시 접근(concurrent access)은 데이터의 불일치 문제(inconsistency)를 발생시킬 수 있다

- 일관성(consistency) 유지를 위해서는 협력 프로세스(cooperating process) 간의 실행 순서(orderly execution)를 정해주는 메커니즘 필요

- Race condition
  
  - 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황
  
  - 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐

- race condition을 막기 위해서는 concurrent process는 동기화(synchronize)되어야 한다

## The Critical-Section Problem

- n 개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우

- 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재

- Problem
  
  - 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다

---

## 프로그램적 해결법의 충족 요건

- Mutual Exclusion
  
  - ㅇ

- Progress
  
  - ㅇ

- Bounded Waiting
  
  - ㅇ

## Initial Attempts to Solve Problem

- 두 개의 프로세스가 있다고 가정
